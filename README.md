# CI2024_lab2
# TSP Exercise

This repository contains the solution to the TSP problem implemented in the Jupyter Notebook `TSP.ipynb` by the student Luca Ianniello, s327313.

## Algorithm Description

## Initialization
The initialization step allows to decide if start the algorithm using a greedy approach or a random path approach. The selection is done using the variable `select_initialization`. 

## Algorithms
The algorithm application allows to decide if use a mutation strategy approach or a crossover strategy approach. This selection is done using the variable `algorithm_selection`.

### Mutation Strategy
The `mutation_algorithm` function operates as follows:

### Initialization
The function begins by setting the current best population and calculating the initial best fitness (cost) using the `tsp_cost` function.

### Main Loop
- The function iterates for the specified number of iterations.
- For each iteration, a copy of the current best population is created as `new_population`.

### Mutation Process
A mutation is applied with a probability defined by `mutation_rate`. If a random number is less than this rate, the function:
- Mutates the paths in `new_population` using a inverted mutation algorithm. 
- Applies a local search to further refine the mutated paths (using the `local_search` function).

### Fitness Evaluation
The fitness of the new population is evaluated using the `tsp_cost` function. If the new fitness is better than the best fitness recorded:
- The best population is updated.
- The best fitness is updated.
- The number of swaps is decreased to focus on exploitation.

### Adaptive Mutation Rate
If no improvement is found:
- The mutation rate is adjusted based on the difference in fitness, promoting exploration.
- The number of swaps is increased to encourage further exploration.

### Decay of Mutation Rate
The mutation rate is gradually decreased over time, promoting convergence as the algorithm progresses.

## Crossover algorithm
The `crossover_algorithm` function operates as follows:

### Initialization:
- The algorithm initializes a `population` containing the input `path` and additional paths generated by the `initialize_population` function.

### Evolution:
- For each generation, a new population (`next_generation`) is created.
  - **Selection**: Two parents are selected from the population using `tournament_selection`.
  - **Crossover**: The `inv_crossover` function is used to produce a child tour from the two parents.
  - **Mutation**: With probability equal to `mutation_rate`, the child is mutated using a inverted mutation algorithm.
  - **Survival**: If the child has a lower cost than either parent, it is added to the next generation. Otherwise, a random parent is retained.

### Progress Reporting:
- Every 10 generations, the algorithm prints the best fitness (i.e., shortest tour) in the population.

### Termination:
- After completing all generations, the function returns the `best_tour` from the final population. This tour represents the shortest path found by the algorithm.

## Results

### Vanuatu

| Method                 | Cost | Number of Steps |
|------------------------|------|-----------------|
| greedy + mutation       |  1475.53    |    10093            |
| greedy + crossover      |  1345.54  |    196369 (500 gen)            |
| random + mutation       |  1345.54   |    10303            |
| random + crossover      |  1345.54   |    196369 (500 gen)            |

### Italy

| Method                 | Cost | Number of Steps |
|------------------------|------|-----------------|
| greedy + mutation       |  4436.03   |    17571            |
| greedy + crossover      |  4306.79   |    1074245 (500 gen) |            
| random + mutation       |  4976.60   |    19463            |
| random + crossover      |  4291.87   |    1074245            |

### Russia

| Method                 | Cost | Number of Steps |
|------------------------|------|-----------------|
| greedy + mutation       |  35805.38   |   442963            |
| greedy + crossover      |  34145.42   |   2333203 (1000 gen)  |           
| random + mutation       |  36656.11   |   145303            |
| random + crossover      |  34665.52   |   2333203 (1000 gen)  | 

The last one continues to improve a bit after the 1000 gen.

### US

| Method                 | Cost | Number of Steps |
|------------------------|------|-----------------|
| greedy + mutation       |  40540.23   |   742567           |
| greedy + crossover      |  40275.63   |   2333203 (1000 gen)     |
| random + mutation       |  40759.67   |   3568171           |
| random + crossover      |  41067.56  |    5832853 (2500 gen)          |

### China

In this case the mutation_algorithm is executed without local search due to complexity.

| Method                 | Cost | Number of Steps |
|------------------------|------|-----------------|
| greedy + mutation       |  54786.93   |   4721071          |
| greedy + crossover      |  55809.75   |   6999403 (3000 gen)         |
| random + mutation       |  965247.20  |  10003           |
| random + crossover      |  61403.21  |    13998703 (6000 gen)       |

## Author

This exercise was completed as part of the Computational Intelligence course, as Lab 1 exercise.


