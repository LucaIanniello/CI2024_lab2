# CI2024_lab2
# TSP Exercise

This repository contains the solution to the TSP problem implemented in the Jupyter Notebook `TSP.ipynb` by the student Luca Ianniello, s327313.

## Algorithm Description

## Initialization
The initialization step allows to decide if start the algorithm using a greedy approach or a random path approach. The selection is done using the variable `select_initialization`. 

## Algorithms
The algorithm application allows to decide if use a mutation strategy approach or a crossover strategy approach. This selection is done using the variable `algorithm_selection`.

### Mutation Strategy
The `mutation_algorithm` function operates as follows:

### Initialization
The function begins by setting the current best population and calculating the initial best fitness (cost) using the `tsp_cost` function.

### Main Loop
- The function iterates for the specified number of iterations.
- For each iteration, a copy of the current best population is created as `new_population`.

### Mutation Process
A mutation is applied with a probability defined by `mutation_rate`. If a random number is less than this rate, the function:
- Mutates the paths in `new_population` by swapping a specified number of cities (using the `mutate` function).
- Applies a local search to further refine the mutated paths (using the `local_search` function).

### Fitness Evaluation
The fitness of the new population is evaluated using the `tsp_cost` function. If the new fitness is better than the best fitness recorded:
- The best population is updated.
- The best fitness is updated.
- The number of swaps is decreased to focus on exploitation.

### Adaptive Mutation Rate
If no improvement is found:
- The mutation rate is adjusted based on the difference in fitness, promoting exploration.
- The number of swaps is increased to encourage further exploration.

### Decay of Mutation Rate
The mutation rate is gradually decreased over time, promoting convergence as the algorithm progresses.

## Crossover algorithm
The `crossover_algorithm` function operates as follows:

### Initialization
- A population list is created that includes the provided `path` and additional paths generated by the `initialize_population` function, which creates a population of random paths.

### Main Loop
- The function iterates for the specified number of generations (`gen_number`).
- In each generation, a new list, `next_generation`, is initialized to store the offspring.

### Creating Offspring
- While the `next_generation` list is not full, the following steps are performed:
  - Two parents are selected from the current population using the `tournament_selection` function.
  - A child is generated by performing a crossover between the two parents using the `inv_crossover` function.
  - The child is added to the `next_generation` list.

### Updating Population
- After creating the new offspring for the generation, the current population is updated to `next_generation`.

### Progress Reporting
- Optionally, the function prints the best fitness found in the current generation every 10 generations by evaluating the fitness of each tour in the population using the `tsp_cost` function.

### Returning the Best Tour
- After all generations have been processed, the function identifies and returns the best tour found in the final population, evaluated using the `tsp_cost` function.

## Author

This exercise was completed as part of the Computational Intelligence course, as Lab 1 exercise.


